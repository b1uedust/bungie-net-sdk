/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package uk.co.bluedust.model;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import uk.co.bluedust.model.DestinyDamageType;
import uk.co.bluedust.model.DestinyDefinitionsAnimationsDestinyAnimationReference;
import uk.co.bluedust.model.DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;
import uk.co.bluedust.model.DestinyDefinitionsDestinyItemInvestmentStatDefinition;
import uk.co.bluedust.model.DestinyDefinitionsDestinyItemPerkEntryDefinition;
import uk.co.bluedust.model.LinksHyperlinkReference;

/**
 * So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.  In practice, you will want to associate this data with \&quot;live\&quot; item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
 */
@ApiModel(description = "So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.  In practice, you will want to associate this data with \"live\" item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-12-08T21:00:47.497Z")
public class DestinyDefinitionsDestinyInventoryItemDefinition {
  @JsonProperty("displayProperties")
  private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties = null;

  @JsonProperty("collectibleHash")
  private Long collectibleHash = null;

  @JsonProperty("secondaryIcon")
  private String secondaryIcon = null;

  @JsonProperty("secondaryOverlay")
  private String secondaryOverlay = null;

  @JsonProperty("secondarySpecial")
  private String secondarySpecial = null;

  @JsonProperty("backgroundColor")
  private Object backgroundColor = null;

  @JsonProperty("screenshot")
  private String screenshot = null;

  @JsonProperty("itemTypeDisplayName")
  private String itemTypeDisplayName = null;

  @JsonProperty("uiItemDisplayStyle")
  private String uiItemDisplayStyle = null;

  @JsonProperty("itemTypeAndTierDisplayName")
  private String itemTypeAndTierDisplayName = null;

  @JsonProperty("displaySource")
  private String displaySource = null;

  @JsonProperty("tooltipStyle")
  private String tooltipStyle = null;

  @JsonProperty("action")
  private Object action = null;

  @JsonProperty("inventory")
  private Object inventory = null;

  @JsonProperty("setData")
  private Object setData = null;

  @JsonProperty("stats")
  private Object stats = null;

  @JsonProperty("emblemObjectiveHash")
  private Long emblemObjectiveHash = null;

  @JsonProperty("equippingBlock")
  private Object equippingBlock = null;

  @JsonProperty("translationBlock")
  private Object translationBlock = null;

  @JsonProperty("preview")
  private Object preview = null;

  @JsonProperty("quality")
  private Object quality = null;

  @JsonProperty("value")
  private Object value = null;

  @JsonProperty("sourceData")
  private Object sourceData = null;

  @JsonProperty("objectives")
  private Object objectives = null;

  @JsonProperty("plug")
  private Object plug = null;

  @JsonProperty("gearset")
  private Object gearset = null;

  @JsonProperty("sack")
  private Object sack = null;

  @JsonProperty("sockets")
  private Object sockets = null;

  @JsonProperty("summary")
  private Object summary = null;

  @JsonProperty("talentGrid")
  private Object talentGrid = null;

  @JsonProperty("investmentStats")
  private List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats = null;

  @JsonProperty("perks")
  private List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks = null;

  @JsonProperty("loreHash")
  private Long loreHash = null;

  @JsonProperty("summaryItemHash")
  private Long summaryItemHash = null;

  @JsonProperty("animations")
  private List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations = null;

  @JsonProperty("allowActions")
  private Boolean allowActions = null;

  @JsonProperty("links")
  private List<LinksHyperlinkReference> links = null;

  @JsonProperty("doesPostmasterPullHaveSideEffects")
  private Boolean doesPostmasterPullHaveSideEffects = null;

  @JsonProperty("nonTransferrable")
  private Boolean nonTransferrable = null;

  @JsonProperty("itemCategoryHashes")
  private List<Long> itemCategoryHashes = null;

  @JsonProperty("specialItemType")
  private Object specialItemType = null;

  @JsonProperty("itemType")
  private Object itemType = null;

  @JsonProperty("itemSubType")
  private Object itemSubType = null;

  @JsonProperty("classType")
  private Object classType = null;

  @JsonProperty("equippable")
  private Boolean equippable = null;

  @JsonProperty("damageTypeHashes")
  private List<Long> damageTypeHashes = null;

  @JsonProperty("damageTypes")
  private List<DestinyDamageType> damageTypes = null;

  @JsonProperty("defaultDamageType")
  private Object defaultDamageType = null;

  @JsonProperty("defaultDamageTypeHash")
  private Long defaultDamageTypeHash = null;

  @JsonProperty("hash")
  private Long hash = null;

  @JsonProperty("index")
  private Integer index = null;

  @JsonProperty("redacted")
  private Boolean redacted = null;

  public DestinyDefinitionsDestinyInventoryItemDefinition displayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
    return this;
  }

   /**
   * Get displayProperties
   * @return displayProperties
  **/
  @ApiModelProperty(value = "")
  public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition getDisplayProperties() {
    return displayProperties;
  }

  public void setDisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties) {
    this.displayProperties = displayProperties;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition collectibleHash(Long collectibleHash) {
    this.collectibleHash = collectibleHash;
    return this;
  }

   /**
   * If this item has a collectible related to it, this is the hash identifier of that collectible entry.
   * @return collectibleHash
  **/
  @ApiModelProperty(value = "If this item has a collectible related to it, this is the hash identifier of that collectible entry.")
  public Long getCollectibleHash() {
    return collectibleHash;
  }

  public void setCollectibleHash(Long collectibleHash) {
    this.collectibleHash = collectibleHash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition secondaryIcon(String secondaryIcon) {
    this.secondaryIcon = secondaryIcon;
    return this;
  }

   /**
   * A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
   * @return secondaryIcon
  **/
  @ApiModelProperty(value = "A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.")
  public String getSecondaryIcon() {
    return secondaryIcon;
  }

  public void setSecondaryIcon(String secondaryIcon) {
    this.secondaryIcon = secondaryIcon;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition secondaryOverlay(String secondaryOverlay) {
    this.secondaryOverlay = secondaryOverlay;
    return this;
  }

   /**
   * Pulled from the secondary icon, this is the \&quot;secondary background\&quot; of the secondary icon. Confusing? Sure, that&#39;s why I call it \&quot;overlay\&quot; here: because as far as it&#39;s been used thus far, it has been for an optional overlay image. We&#39;ll see if that holds up, but at least for now it explains what this image is a bit better.
   * @return secondaryOverlay
  **/
  @ApiModelProperty(value = "Pulled from the secondary icon, this is the \"secondary background\" of the secondary icon. Confusing? Sure, that's why I call it \"overlay\" here: because as far as it's been used thus far, it has been for an optional overlay image. We'll see if that holds up, but at least for now it explains what this image is a bit better.")
  public String getSecondaryOverlay() {
    return secondaryOverlay;
  }

  public void setSecondaryOverlay(String secondaryOverlay) {
    this.secondaryOverlay = secondaryOverlay;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition secondarySpecial(String secondarySpecial) {
    this.secondarySpecial = secondarySpecial;
    return this;
  }

   /**
   * Pulled from the Secondary Icon, this is the \&quot;special\&quot; background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
   * @return secondarySpecial
  **/
  @ApiModelProperty(value = "Pulled from the Secondary Icon, this is the \"special\" background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.")
  public String getSecondarySpecial() {
    return secondarySpecial;
  }

  public void setSecondarySpecial(String secondarySpecial) {
    this.secondarySpecial = secondarySpecial;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition backgroundColor(Object backgroundColor) {
    this.backgroundColor = backgroundColor;
    return this;
  }

   /**
   * Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the \&quot;friends\&quot; view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.
   * @return backgroundColor
  **/
  @ApiModelProperty(value = "Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the \"friends\" view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.")
  public Object getBackgroundColor() {
    return backgroundColor;
  }

  public void setBackgroundColor(Object backgroundColor) {
    this.backgroundColor = backgroundColor;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition screenshot(String screenshot) {
    this.screenshot = screenshot;
    return this;
  }

   /**
   * If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
   * @return screenshot
  **/
  @ApiModelProperty(value = "If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.")
  public String getScreenshot() {
    return screenshot;
  }

  public void setScreenshot(String screenshot) {
    this.screenshot = screenshot;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition itemTypeDisplayName(String itemTypeDisplayName) {
    this.itemTypeDisplayName = itemTypeDisplayName;
    return this;
  }

   /**
   * The localized title/name of the item&#39;s type. This can be whatever the designers want, and has no guarantee of consistency between items.
   * @return itemTypeDisplayName
  **/
  @ApiModelProperty(value = "The localized title/name of the item's type. This can be whatever the designers want, and has no guarantee of consistency between items.")
  public String getItemTypeDisplayName() {
    return itemTypeDisplayName;
  }

  public void setItemTypeDisplayName(String itemTypeDisplayName) {
    this.itemTypeDisplayName = itemTypeDisplayName;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition uiItemDisplayStyle(String uiItemDisplayStyle) {
    this.uiItemDisplayStyle = uiItemDisplayStyle;
    return this;
  }

   /**
   * A string identifier that the game&#39;s UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don&#39;t have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!
   * @return uiItemDisplayStyle
  **/
  @ApiModelProperty(value = "A string identifier that the game's UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don't have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!")
  public String getUiItemDisplayStyle() {
    return uiItemDisplayStyle;
  }

  public void setUiItemDisplayStyle(String uiItemDisplayStyle) {
    this.uiItemDisplayStyle = uiItemDisplayStyle;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition itemTypeAndTierDisplayName(String itemTypeAndTierDisplayName) {
    this.itemTypeAndTierDisplayName = itemTypeAndTierDisplayName;
    return this;
  }

   /**
   * It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I&#39;m just going to go ahead and start pre-creating these for items.
   * @return itemTypeAndTierDisplayName
  **/
  @ApiModelProperty(value = "It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I'm just going to go ahead and start pre-creating these for items.")
  public String getItemTypeAndTierDisplayName() {
    return itemTypeAndTierDisplayName;
  }

  public void setItemTypeAndTierDisplayName(String itemTypeAndTierDisplayName) {
    this.itemTypeAndTierDisplayName = itemTypeAndTierDisplayName;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition displaySource(String displaySource) {
    this.displaySource = displaySource;
    return this;
  }

   /**
   * In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it&#39;s instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
   * @return displaySource
  **/
  @ApiModelProperty(value = "In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.")
  public String getDisplaySource() {
    return displaySource;
  }

  public void setDisplaySource(String displaySource) {
    this.displaySource = displaySource;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition tooltipStyle(String tooltipStyle) {
    this.tooltipStyle = tooltipStyle;
    return this;
  }

   /**
   * An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it&#39;ll be up to you to interpret and display your UI differently according to these styles (or ignore it).
   * @return tooltipStyle
  **/
  @ApiModelProperty(value = "An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and display your UI differently according to these styles (or ignore it).")
  public String getTooltipStyle() {
    return tooltipStyle;
  }

  public void setTooltipStyle(String tooltipStyle) {
    this.tooltipStyle = tooltipStyle;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition action(Object action) {
    this.action = action;
    return this;
  }

   /**
   * If the item can be \&quot;used\&quot;, this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is \&quot;dismantle\&quot;. Shocker)
   * @return action
  **/
  @ApiModelProperty(value = "If the item can be \"used\", this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is \"dismantle\". Shocker)")
  public Object getAction() {
    return action;
  }

  public void setAction(Object action) {
    this.action = action;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition inventory(Object inventory) {
    this.inventory = inventory;
    return this;
  }

   /**
   * If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
   * @return inventory
  **/
  @ApiModelProperty(value = "If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.")
  public Object getInventory() {
    return inventory;
  }

  public void setInventory(Object inventory) {
    this.inventory = inventory;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition setData(Object setData) {
    this.setData = setData;
    return this;
  }

   /**
   * If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn&#39;t clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.
   * @return setData
  **/
  @ApiModelProperty(value = "If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.")
  public Object getSetData() {
    return setData;
  }

  public void setSetData(Object setData) {
    this.setData = setData;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition stats(Object stats) {
    this.stats = stats;
    return this;
  }

   /**
   * If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.
   * @return stats
  **/
  @ApiModelProperty(value = "If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.")
  public Object getStats() {
    return stats;
  }

  public void setStats(Object stats) {
    this.stats = stats;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition emblemObjectiveHash(Long emblemObjectiveHash) {
    this.emblemObjectiveHash = emblemObjectiveHash;
    return this;
  }

   /**
   * If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \&quot;art channel\&quot;. When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they&#39;re being used for and how they are wired up, but for now here&#39;s the raw data.
   * @return emblemObjectiveHash
  **/
  @ApiModelProperty(value = "If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \"art channel\". When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they're being used for and how they are wired up, but for now here's the raw data.")
  public Long getEmblemObjectiveHash() {
    return emblemObjectiveHash;
  }

  public void setEmblemObjectiveHash(Long emblemObjectiveHash) {
    this.emblemObjectiveHash = emblemObjectiveHash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition equippingBlock(Object equippingBlock) {
    this.equippingBlock = equippingBlock;
    return this;
  }

   /**
   * If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.
   * @return equippingBlock
  **/
  @ApiModelProperty(value = "If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.")
  public Object getEquippingBlock() {
    return equippingBlock;
  }

  public void setEquippingBlock(Object equippingBlock) {
    this.equippingBlock = equippingBlock;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition translationBlock(Object translationBlock) {
    this.translationBlock = translationBlock;
    return this;
  }

   /**
   * If this item can be rendered, this block will be non-null and will be populated with rendering information.
   * @return translationBlock
  **/
  @ApiModelProperty(value = "If this item can be rendered, this block will be non-null and will be populated with rendering information.")
  public Object getTranslationBlock() {
    return translationBlock;
  }

  public void setTranslationBlock(Object translationBlock) {
    this.translationBlock = translationBlock;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition preview(Object preview) {
    this.preview = preview;
    return this;
  }

   /**
   * If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.
   * @return preview
  **/
  @ApiModelProperty(value = "If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.")
  public Object getPreview() {
    return preview;
  }

  public void setPreview(Object preview) {
    this.preview = preview;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition quality(Object quality) {
    this.quality = quality;
    return this;
  }

   /**
   * If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, \&quot;quality\&quot;, and infusion) data. See the block for more details, there&#39;s often less upfront information in D2 so you&#39;ll want to be aware of how you use quality and item level on the definition level now.
   * @return quality
  **/
  @ApiModelProperty(value = "If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, \"quality\", and infusion) data. See the block for more details, there's often less upfront information in D2 so you'll want to be aware of how you use quality and item level on the definition level now.")
  public Object getQuality() {
    return quality;
  }

  public void setQuality(Object quality) {
    this.quality = quality;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition value(Object value) {
    this.value = value;
    return this;
  }

   /**
   * The conceptual \&quot;Value\&quot; of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.
   * @return value
  **/
  @ApiModelProperty(value = "The conceptual \"Value\" of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.")
  public Object getValue() {
    return value;
  }

  public void setValue(Object value) {
    this.value = value;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition sourceData(Object sourceData) {
    this.sourceData = sourceData;
    return this;
  }

   /**
   * If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn&#39;t have time for, and I&#39;m hoping to get back to at some point in the future.
   * @return sourceData
  **/
  @ApiModelProperty(value = "If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn't have time for, and I'm hoping to get back to at some point in the future.")
  public Object getSourceData() {
    return sourceData;
  }

  public void setSourceData(Object sourceData) {
    this.sourceData = sourceData;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition objectives(Object objectives) {
    this.objectives = objectives;
    return this;
  }

   /**
   * If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.
   * @return objectives
  **/
  @ApiModelProperty(value = "If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.")
  public Object getObjectives() {
    return objectives;
  }

  public void setObjectives(Object objectives) {
    this.objectives = objectives;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition plug(Object plug) {
    this.plug = plug;
    return this;
  }

   /**
   * If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.
   * @return plug
  **/
  @ApiModelProperty(value = "If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.")
  public Object getPlug() {
    return plug;
  }

  public void setPlug(Object plug) {
    this.plug = plug;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition gearset(Object gearset) {
    this.gearset = gearset;
    return this;
  }

   /**
   * If this item has related items in a \&quot;Gear Set\&quot;, this will be non-null and the relationships defined herein.
   * @return gearset
  **/
  @ApiModelProperty(value = "If this item has related items in a \"Gear Set\", this will be non-null and the relationships defined herein.")
  public Object getGearset() {
    return gearset;
  }

  public void setGearset(Object gearset) {
    this.gearset = gearset;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition sack(Object sack) {
    this.sack = sack;
    return this;
  }

   /**
   * If this item is a \&quot;reward sack\&quot; that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.
   * @return sack
  **/
  @ApiModelProperty(value = "If this item is a \"reward sack\" that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.")
  public Object getSack() {
    return sack;
  }

  public void setSack(Object sack) {
    this.sack = sack;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition sockets(Object sockets) {
    this.sockets = sockets;
    return this;
  }

   /**
   * If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.
   * @return sockets
  **/
  @ApiModelProperty(value = "If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.")
  public Object getSockets() {
    return sockets;
  }

  public void setSockets(Object sockets) {
    this.sockets = sockets;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition summary(Object summary) {
    this.summary = summary;
    return this;
  }

   /**
   * Summary data about the item.
   * @return summary
  **/
  @ApiModelProperty(value = "Summary data about the item.")
  public Object getSummary() {
    return summary;
  }

  public void setSummary(Object summary) {
    this.summary = summary;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition talentGrid(Object talentGrid) {
    this.talentGrid = talentGrid;
    return this;
  }

   /**
   * If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/\&quot;Build\&quot; items.
   * @return talentGrid
  **/
  @ApiModelProperty(value = "If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/\"Build\" items.")
  public Object getTalentGrid() {
    return talentGrid;
  }

  public void setTalentGrid(Object talentGrid) {
    this.talentGrid = talentGrid;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition investmentStats(List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats) {
    this.investmentStats = investmentStats;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addInvestmentStatsItem(DestinyDefinitionsDestinyItemInvestmentStatDefinition investmentStatsItem) {
    if (this.investmentStats == null) {
      this.investmentStats = new ArrayList<>();
    }
    this.investmentStats.add(investmentStatsItem);
    return this;
  }

   /**
   * If the item has stats, this block will be defined. It has the \&quot;raw\&quot; investment stats for the item. These investment stats don&#39;t take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
   * @return investmentStats
  **/
  @ApiModelProperty(value = "If the item has stats, this block will be defined. It has the \"raw\" investment stats for the item. These investment stats don't take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.")
  public List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> getInvestmentStats() {
    return investmentStats;
  }

  public void setInvestmentStats(List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats) {
    this.investmentStats = investmentStats;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition perks(List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks) {
    this.perks = perks;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addPerksItem(DestinyDefinitionsDestinyItemPerkEntryDefinition perksItem) {
    if (this.perks == null) {
      this.perks = new ArrayList<>();
    }
    this.perks.add(perksItem);
    return this;
  }

   /**
   * If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
   * @return perks
  **/
  @ApiModelProperty(value = "If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.")
  public List<DestinyDefinitionsDestinyItemPerkEntryDefinition> getPerks() {
    return perks;
  }

  public void setPerks(List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks) {
    this.perks = perks;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition loreHash(Long loreHash) {
    this.loreHash = loreHash;
    return this;
  }

   /**
   * If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
   * @return loreHash
  **/
  @ApiModelProperty(value = "If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.")
  public Long getLoreHash() {
    return loreHash;
  }

  public void setLoreHash(Long loreHash) {
    this.loreHash = loreHash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition summaryItemHash(Long summaryItemHash) {
    this.summaryItemHash = summaryItemHash;
    return this;
  }

   /**
   * There are times when the game will show you a \&quot;summary/vague\&quot; version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
   * @return summaryItemHash
  **/
  @ApiModelProperty(value = "There are times when the game will show you a \"summary/vague\" version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.")
  public Long getSummaryItemHash() {
    return summaryItemHash;
  }

  public void setSummaryItemHash(Long summaryItemHash) {
    this.summaryItemHash = summaryItemHash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition animations(List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations) {
    this.animations = animations;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addAnimationsItem(DestinyDefinitionsAnimationsDestinyAnimationReference animationsItem) {
    if (this.animations == null) {
      this.animations = new ArrayList<>();
    }
    this.animations.add(animationsItem);
    return this;
  }

   /**
   * If any animations were extracted from game content for this item, these will be the definitions of those animations.
   * @return animations
  **/
  @ApiModelProperty(value = "If any animations were extracted from game content for this item, these will be the definitions of those animations.")
  public List<DestinyDefinitionsAnimationsDestinyAnimationReference> getAnimations() {
    return animations;
  }

  public void setAnimations(List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations) {
    this.animations = animations;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition allowActions(Boolean allowActions) {
    this.allowActions = allowActions;
    return this;
  }

   /**
   * BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
   * @return allowActions
  **/
  @ApiModelProperty(value = "BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.")
  public Boolean isAllowActions() {
    return allowActions;
  }

  public void setAllowActions(Boolean allowActions) {
    this.allowActions = allowActions;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition links(List<LinksHyperlinkReference> links) {
    this.links = links;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addLinksItem(LinksHyperlinkReference linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * If we added any help or informational URLs about this item, these will be those links.
   * @return links
  **/
  @ApiModelProperty(value = "If we added any help or informational URLs about this item, these will be those links.")
  public List<LinksHyperlinkReference> getLinks() {
    return links;
  }

  public void setLinks(List<LinksHyperlinkReference> links) {
    this.links = links;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition doesPostmasterPullHaveSideEffects(Boolean doesPostmasterPullHaveSideEffects) {
    this.doesPostmasterPullHaveSideEffects = doesPostmasterPullHaveSideEffects;
    return this;
  }

   /**
   * The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \&quot;destructive\&quot; action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you&#39;ll end up receiving an error.
   * @return doesPostmasterPullHaveSideEffects
  **/
  @ApiModelProperty(value = "The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \"destructive\" action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you'll end up receiving an error.")
  public Boolean isDoesPostmasterPullHaveSideEffects() {
    return doesPostmasterPullHaveSideEffects;
  }

  public void setDoesPostmasterPullHaveSideEffects(Boolean doesPostmasterPullHaveSideEffects) {
    this.doesPostmasterPullHaveSideEffects = doesPostmasterPullHaveSideEffects;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition nonTransferrable(Boolean nonTransferrable) {
    this.nonTransferrable = nonTransferrable;
    return this;
  }

   /**
   * The intrinsic transferability of an item.  I hate that this boolean is negative - but there&#39;s a reason.  Just because an item is intrinsically transferrable doesn&#39;t mean that it can be transferred, and we don&#39;t want to imply that this is the only source of that transferability.
   * @return nonTransferrable
  **/
  @ApiModelProperty(value = "The intrinsic transferability of an item.  I hate that this boolean is negative - but there's a reason.  Just because an item is intrinsically transferrable doesn't mean that it can be transferred, and we don't want to imply that this is the only source of that transferability.")
  public Boolean isNonTransferrable() {
    return nonTransferrable;
  }

  public void setNonTransferrable(Boolean nonTransferrable) {
    this.nonTransferrable = nonTransferrable;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition itemCategoryHashes(List<Long> itemCategoryHashes) {
    this.itemCategoryHashes = itemCategoryHashes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addItemCategoryHashesItem(Long itemCategoryHashesItem) {
    if (this.itemCategoryHashes == null) {
      this.itemCategoryHashes = new ArrayList<>();
    }
    this.itemCategoryHashes.add(itemCategoryHashesItem);
    return this;
  }

   /**
   * BNet attempts to make a more formal definition of item \&quot;Categories\&quot;, as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it&#39;s a \&quot;Weapon\&quot;, that it&#39;s an \&quot;Auto Rifle\&quot;, etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
   * @return itemCategoryHashes
  **/
  @ApiModelProperty(value = "BNet attempts to make a more formal definition of item \"Categories\", as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it's a \"Weapon\", that it's an \"Auto Rifle\", etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.")
  public List<Long> getItemCategoryHashes() {
    return itemCategoryHashes;
  }

  public void setItemCategoryHashes(List<Long> itemCategoryHashes) {
    this.itemCategoryHashes = itemCategoryHashes;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition specialItemType(Object specialItemType) {
    this.specialItemType = specialItemType;
    return this;
  }

   /**
   * In Destiny 1, we identified some items as having particular categories that we&#39;d like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return specialItemType
  **/
  @ApiModelProperty(value = "In Destiny 1, we identified some items as having particular categories that we'd like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.")
  public Object getSpecialItemType() {
    return specialItemType;
  }

  public void setSpecialItemType(Object specialItemType) {
    this.specialItemType = specialItemType;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition itemType(Object itemType) {
    this.itemType = itemType;
    return this;
  }

   /**
   * A value indicating the \&quot;base\&quot; the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \&quot;Type\&quot;. Still, it&#39;s handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return itemType
  **/
  @ApiModelProperty(value = "A value indicating the \"base\" the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \"Type\". Still, it's handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.")
  public Object getItemType() {
    return itemType;
  }

  public void setItemType(Object itemType) {
    this.itemType = itemType;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition itemSubType(Object itemSubType) {
    this.itemSubType = itemSubType;
    return this;
  }

   /**
   * A value indicating the \&quot;sub-type\&quot; of the item. For instance, where an item might have an itemType value \&quot;Weapon\&quot;, this will be something more specific like \&quot;Auto Rifle\&quot;.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   * @return itemSubType
  **/
  @ApiModelProperty(value = "A value indicating the \"sub-type\" of the item. For instance, where an item might have an itemType value \"Weapon\", this will be something more specific like \"Auto Rifle\".  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.")
  public Object getItemSubType() {
    return itemSubType;
  }

  public void setItemSubType(Object itemSubType) {
    this.itemSubType = itemSubType;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition classType(Object classType) {
    this.classType = classType;
    return this;
  }

   /**
   * We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class&#39; enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.
   * @return classType
  **/
  @ApiModelProperty(value = "We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class' enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.")
  public Object getClassType() {
    return classType;
  }

  public void setClassType(Object classType) {
    this.classType = classType;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition equippable(Boolean equippable) {
    this.equippable = equippable;
    return this;
  }

   /**
   * If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.
   * @return equippable
  **/
  @ApiModelProperty(value = "If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.")
  public Boolean isEquippable() {
    return equippable;
  }

  public void setEquippable(Boolean equippable) {
    this.equippable = equippable;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition damageTypeHashes(List<Long> damageTypeHashes) {
    this.damageTypeHashes = damageTypeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addDamageTypeHashesItem(Long damageTypeHashesItem) {
    if (this.damageTypeHashes == null) {
      this.damageTypeHashes = new ArrayList<>();
    }
    this.damageTypeHashes.add(damageTypeHashesItem);
    return this;
  }

   /**
   * Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
   * @return damageTypeHashes
  **/
  @ApiModelProperty(value = "Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.")
  public List<Long> getDamageTypeHashes() {
    return damageTypeHashes;
  }

  public void setDamageTypeHashes(List<Long> damageTypeHashes) {
    this.damageTypeHashes = damageTypeHashes;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition damageTypes(List<DestinyDamageType> damageTypes) {
    this.damageTypes = damageTypes;
    return this;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition addDamageTypesItem(DestinyDamageType damageTypesItem) {
    if (this.damageTypes == null) {
      this.damageTypes = new ArrayList<>();
    }
    this.damageTypes.add(damageTypesItem);
    return this;
  }

   /**
   * This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets
   * @return damageTypes
  **/
  @ApiModelProperty(value = "This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets")
  public List<DestinyDamageType> getDamageTypes() {
    return damageTypes;
  }

  public void setDamageTypes(List<DestinyDamageType> damageTypes) {
    this.damageTypes = damageTypes;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition defaultDamageType(Object defaultDamageType) {
    this.defaultDamageType = defaultDamageType;
    return this;
  }

   /**
   * If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it&#39;s surprisingly cumbersome to figure this out. I hope you&#39;re happy.
   * @return defaultDamageType
  **/
  @ApiModelProperty(value = "If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.")
  public Object getDefaultDamageType() {
    return defaultDamageType;
  }

  public void setDefaultDamageType(Object defaultDamageType) {
    this.defaultDamageType = defaultDamageType;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition defaultDamageTypeHash(Long defaultDamageTypeHash) {
    this.defaultDamageTypeHash = defaultDamageTypeHash;
    return this;
  }

   /**
   * Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they&#39;re very convenient.
   * @return defaultDamageTypeHash
  **/
  @ApiModelProperty(value = "Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they're very convenient.")
  public Long getDefaultDamageTypeHash() {
    return defaultDamageTypeHash;
  }

  public void setDefaultDamageTypeHash(Long defaultDamageTypeHash) {
    this.defaultDamageTypeHash = defaultDamageTypeHash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition hash(Long hash) {
    this.hash = hash;
    return this;
  }

   /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
   * @return hash
  **/
  @ApiModelProperty(value = "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.")
  public Long getHash() {
    return hash;
  }

  public void setHash(Long hash) {
    this.hash = hash;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition index(Integer index) {
    this.index = index;
    return this;
  }

   /**
   * The index of the entity as it was found in the investment tables.
   * @return index
  **/
  @ApiModelProperty(value = "The index of the entity as it was found in the investment tables.")
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }

  public DestinyDefinitionsDestinyInventoryItemDefinition redacted(Boolean redacted) {
    this.redacted = redacted;
    return this;
  }

   /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   * @return redacted
  **/
  @ApiModelProperty(value = "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!")
  public Boolean isRedacted() {
    return redacted;
  }

  public void setRedacted(Boolean redacted) {
    this.redacted = redacted;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyInventoryItemDefinition destinyDefinitionsDestinyInventoryItemDefinition = (DestinyDefinitionsDestinyInventoryItemDefinition) o;
    return Objects.equals(this.displayProperties, destinyDefinitionsDestinyInventoryItemDefinition.displayProperties) &&
        Objects.equals(this.collectibleHash, destinyDefinitionsDestinyInventoryItemDefinition.collectibleHash) &&
        Objects.equals(this.secondaryIcon, destinyDefinitionsDestinyInventoryItemDefinition.secondaryIcon) &&
        Objects.equals(this.secondaryOverlay, destinyDefinitionsDestinyInventoryItemDefinition.secondaryOverlay) &&
        Objects.equals(this.secondarySpecial, destinyDefinitionsDestinyInventoryItemDefinition.secondarySpecial) &&
        Objects.equals(this.backgroundColor, destinyDefinitionsDestinyInventoryItemDefinition.backgroundColor) &&
        Objects.equals(this.screenshot, destinyDefinitionsDestinyInventoryItemDefinition.screenshot) &&
        Objects.equals(this.itemTypeDisplayName, destinyDefinitionsDestinyInventoryItemDefinition.itemTypeDisplayName) &&
        Objects.equals(this.uiItemDisplayStyle, destinyDefinitionsDestinyInventoryItemDefinition.uiItemDisplayStyle) &&
        Objects.equals(this.itemTypeAndTierDisplayName, destinyDefinitionsDestinyInventoryItemDefinition.itemTypeAndTierDisplayName) &&
        Objects.equals(this.displaySource, destinyDefinitionsDestinyInventoryItemDefinition.displaySource) &&
        Objects.equals(this.tooltipStyle, destinyDefinitionsDestinyInventoryItemDefinition.tooltipStyle) &&
        Objects.equals(this.action, destinyDefinitionsDestinyInventoryItemDefinition.action) &&
        Objects.equals(this.inventory, destinyDefinitionsDestinyInventoryItemDefinition.inventory) &&
        Objects.equals(this.setData, destinyDefinitionsDestinyInventoryItemDefinition.setData) &&
        Objects.equals(this.stats, destinyDefinitionsDestinyInventoryItemDefinition.stats) &&
        Objects.equals(this.emblemObjectiveHash, destinyDefinitionsDestinyInventoryItemDefinition.emblemObjectiveHash) &&
        Objects.equals(this.equippingBlock, destinyDefinitionsDestinyInventoryItemDefinition.equippingBlock) &&
        Objects.equals(this.translationBlock, destinyDefinitionsDestinyInventoryItemDefinition.translationBlock) &&
        Objects.equals(this.preview, destinyDefinitionsDestinyInventoryItemDefinition.preview) &&
        Objects.equals(this.quality, destinyDefinitionsDestinyInventoryItemDefinition.quality) &&
        Objects.equals(this.value, destinyDefinitionsDestinyInventoryItemDefinition.value) &&
        Objects.equals(this.sourceData, destinyDefinitionsDestinyInventoryItemDefinition.sourceData) &&
        Objects.equals(this.objectives, destinyDefinitionsDestinyInventoryItemDefinition.objectives) &&
        Objects.equals(this.plug, destinyDefinitionsDestinyInventoryItemDefinition.plug) &&
        Objects.equals(this.gearset, destinyDefinitionsDestinyInventoryItemDefinition.gearset) &&
        Objects.equals(this.sack, destinyDefinitionsDestinyInventoryItemDefinition.sack) &&
        Objects.equals(this.sockets, destinyDefinitionsDestinyInventoryItemDefinition.sockets) &&
        Objects.equals(this.summary, destinyDefinitionsDestinyInventoryItemDefinition.summary) &&
        Objects.equals(this.talentGrid, destinyDefinitionsDestinyInventoryItemDefinition.talentGrid) &&
        Objects.equals(this.investmentStats, destinyDefinitionsDestinyInventoryItemDefinition.investmentStats) &&
        Objects.equals(this.perks, destinyDefinitionsDestinyInventoryItemDefinition.perks) &&
        Objects.equals(this.loreHash, destinyDefinitionsDestinyInventoryItemDefinition.loreHash) &&
        Objects.equals(this.summaryItemHash, destinyDefinitionsDestinyInventoryItemDefinition.summaryItemHash) &&
        Objects.equals(this.animations, destinyDefinitionsDestinyInventoryItemDefinition.animations) &&
        Objects.equals(this.allowActions, destinyDefinitionsDestinyInventoryItemDefinition.allowActions) &&
        Objects.equals(this.links, destinyDefinitionsDestinyInventoryItemDefinition.links) &&
        Objects.equals(this.doesPostmasterPullHaveSideEffects, destinyDefinitionsDestinyInventoryItemDefinition.doesPostmasterPullHaveSideEffects) &&
        Objects.equals(this.nonTransferrable, destinyDefinitionsDestinyInventoryItemDefinition.nonTransferrable) &&
        Objects.equals(this.itemCategoryHashes, destinyDefinitionsDestinyInventoryItemDefinition.itemCategoryHashes) &&
        Objects.equals(this.specialItemType, destinyDefinitionsDestinyInventoryItemDefinition.specialItemType) &&
        Objects.equals(this.itemType, destinyDefinitionsDestinyInventoryItemDefinition.itemType) &&
        Objects.equals(this.itemSubType, destinyDefinitionsDestinyInventoryItemDefinition.itemSubType) &&
        Objects.equals(this.classType, destinyDefinitionsDestinyInventoryItemDefinition.classType) &&
        Objects.equals(this.equippable, destinyDefinitionsDestinyInventoryItemDefinition.equippable) &&
        Objects.equals(this.damageTypeHashes, destinyDefinitionsDestinyInventoryItemDefinition.damageTypeHashes) &&
        Objects.equals(this.damageTypes, destinyDefinitionsDestinyInventoryItemDefinition.damageTypes) &&
        Objects.equals(this.defaultDamageType, destinyDefinitionsDestinyInventoryItemDefinition.defaultDamageType) &&
        Objects.equals(this.defaultDamageTypeHash, destinyDefinitionsDestinyInventoryItemDefinition.defaultDamageTypeHash) &&
        Objects.equals(this.hash, destinyDefinitionsDestinyInventoryItemDefinition.hash) &&
        Objects.equals(this.index, destinyDefinitionsDestinyInventoryItemDefinition.index) &&
        Objects.equals(this.redacted, destinyDefinitionsDestinyInventoryItemDefinition.redacted);
  }

  @Override
  public int hashCode() {
    return Objects.hash(displayProperties, collectibleHash, secondaryIcon, secondaryOverlay, secondarySpecial, backgroundColor, screenshot, itemTypeDisplayName, uiItemDisplayStyle, itemTypeAndTierDisplayName, displaySource, tooltipStyle, action, inventory, setData, stats, emblemObjectiveHash, equippingBlock, translationBlock, preview, quality, value, sourceData, objectives, plug, gearset, sack, sockets, summary, talentGrid, investmentStats, perks, loreHash, summaryItemHash, animations, allowActions, links, doesPostmasterPullHaveSideEffects, nonTransferrable, itemCategoryHashes, specialItemType, itemType, itemSubType, classType, equippable, damageTypeHashes, damageTypes, defaultDamageType, defaultDamageTypeHash, hash, index, redacted);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyInventoryItemDefinition {\n");
    
    sb.append("    displayProperties: ").append(toIndentedString(displayProperties)).append("\n");
    sb.append("    collectibleHash: ").append(toIndentedString(collectibleHash)).append("\n");
    sb.append("    secondaryIcon: ").append(toIndentedString(secondaryIcon)).append("\n");
    sb.append("    secondaryOverlay: ").append(toIndentedString(secondaryOverlay)).append("\n");
    sb.append("    secondarySpecial: ").append(toIndentedString(secondarySpecial)).append("\n");
    sb.append("    backgroundColor: ").append(toIndentedString(backgroundColor)).append("\n");
    sb.append("    screenshot: ").append(toIndentedString(screenshot)).append("\n");
    sb.append("    itemTypeDisplayName: ").append(toIndentedString(itemTypeDisplayName)).append("\n");
    sb.append("    uiItemDisplayStyle: ").append(toIndentedString(uiItemDisplayStyle)).append("\n");
    sb.append("    itemTypeAndTierDisplayName: ").append(toIndentedString(itemTypeAndTierDisplayName)).append("\n");
    sb.append("    displaySource: ").append(toIndentedString(displaySource)).append("\n");
    sb.append("    tooltipStyle: ").append(toIndentedString(tooltipStyle)).append("\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    inventory: ").append(toIndentedString(inventory)).append("\n");
    sb.append("    setData: ").append(toIndentedString(setData)).append("\n");
    sb.append("    stats: ").append(toIndentedString(stats)).append("\n");
    sb.append("    emblemObjectiveHash: ").append(toIndentedString(emblemObjectiveHash)).append("\n");
    sb.append("    equippingBlock: ").append(toIndentedString(equippingBlock)).append("\n");
    sb.append("    translationBlock: ").append(toIndentedString(translationBlock)).append("\n");
    sb.append("    preview: ").append(toIndentedString(preview)).append("\n");
    sb.append("    quality: ").append(toIndentedString(quality)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    sourceData: ").append(toIndentedString(sourceData)).append("\n");
    sb.append("    objectives: ").append(toIndentedString(objectives)).append("\n");
    sb.append("    plug: ").append(toIndentedString(plug)).append("\n");
    sb.append("    gearset: ").append(toIndentedString(gearset)).append("\n");
    sb.append("    sack: ").append(toIndentedString(sack)).append("\n");
    sb.append("    sockets: ").append(toIndentedString(sockets)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    talentGrid: ").append(toIndentedString(talentGrid)).append("\n");
    sb.append("    investmentStats: ").append(toIndentedString(investmentStats)).append("\n");
    sb.append("    perks: ").append(toIndentedString(perks)).append("\n");
    sb.append("    loreHash: ").append(toIndentedString(loreHash)).append("\n");
    sb.append("    summaryItemHash: ").append(toIndentedString(summaryItemHash)).append("\n");
    sb.append("    animations: ").append(toIndentedString(animations)).append("\n");
    sb.append("    allowActions: ").append(toIndentedString(allowActions)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    doesPostmasterPullHaveSideEffects: ").append(toIndentedString(doesPostmasterPullHaveSideEffects)).append("\n");
    sb.append("    nonTransferrable: ").append(toIndentedString(nonTransferrable)).append("\n");
    sb.append("    itemCategoryHashes: ").append(toIndentedString(itemCategoryHashes)).append("\n");
    sb.append("    specialItemType: ").append(toIndentedString(specialItemType)).append("\n");
    sb.append("    itemType: ").append(toIndentedString(itemType)).append("\n");
    sb.append("    itemSubType: ").append(toIndentedString(itemSubType)).append("\n");
    sb.append("    classType: ").append(toIndentedString(classType)).append("\n");
    sb.append("    equippable: ").append(toIndentedString(equippable)).append("\n");
    sb.append("    damageTypeHashes: ").append(toIndentedString(damageTypeHashes)).append("\n");
    sb.append("    damageTypes: ").append(toIndentedString(damageTypes)).append("\n");
    sb.append("    defaultDamageType: ").append(toIndentedString(defaultDamageType)).append("\n");
    sb.append("    defaultDamageTypeHash: ").append(toIndentedString(defaultDamageTypeHash)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    redacted: ").append(toIndentedString(redacted)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

