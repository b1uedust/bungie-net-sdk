/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package uk.co.bluedust.model;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.time.OffsetDateTime;

/**
 * The base item component, filled with properties that are generally useful to know in any item request or that don&#39;t feel worthwhile to put in their own component.
 */
@ApiModel(description = "The base item component, filled with properties that are generally useful to know in any item request or that don't feel worthwhile to put in their own component.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-12-08T21:00:47.497Z")
public class DestinyEntitiesItemsDestinyItemComponent {
  @JsonProperty("itemHash")
  private Long itemHash = null;

  @JsonProperty("itemInstanceId")
  private Long itemInstanceId = null;

  @JsonProperty("quantity")
  private Integer quantity = null;

  @JsonProperty("bindStatus")
  private Object bindStatus = null;

  @JsonProperty("location")
  private Object location = null;

  @JsonProperty("bucketHash")
  private Long bucketHash = null;

  @JsonProperty("transferStatus")
  private Object transferStatus = null;

  @JsonProperty("lockable")
  private Boolean lockable = null;

  @JsonProperty("state")
  private Object state = null;

  @JsonProperty("overrideStyleItemHash")
  private Long overrideStyleItemHash = null;

  @JsonProperty("expirationDate")
  private OffsetDateTime expirationDate = null;

  public DestinyEntitiesItemsDestinyItemComponent itemHash(Long itemHash) {
    this.itemHash = itemHash;
    return this;
  }

   /**
   * The identifier for the item&#39;s definition, which is where most of the useful static information for the item can be found.
   * @return itemHash
  **/
  @ApiModelProperty(value = "The identifier for the item's definition, which is where most of the useful static information for the item can be found.")
  public Long getItemHash() {
    return itemHash;
  }

  public void setItemHash(Long itemHash) {
    this.itemHash = itemHash;
  }

  public DestinyEntitiesItemsDestinyItemComponent itemInstanceId(Long itemInstanceId) {
    this.itemInstanceId = itemInstanceId;
    return this;
  }

   /**
   * If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.
   * @return itemInstanceId
  **/
  @ApiModelProperty(value = "If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.")
  public Long getItemInstanceId() {
    return itemInstanceId;
  }

  public void setItemInstanceId(Long itemInstanceId) {
    this.itemInstanceId = itemInstanceId;
  }

  public DestinyEntitiesItemsDestinyItemComponent quantity(Integer quantity) {
    this.quantity = quantity;
    return this;
  }

   /**
   * The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)
   * @return quantity
  **/
  @ApiModelProperty(value = "The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)")
  public Integer getQuantity() {
    return quantity;
  }

  public void setQuantity(Integer quantity) {
    this.quantity = quantity;
  }

  public DestinyEntitiesItemsDestinyItemComponent bindStatus(Object bindStatus) {
    this.bindStatus = bindStatus;
    return this;
  }

   /**
   * If the item is bound to a location, it will be specified in this enum.
   * @return bindStatus
  **/
  @ApiModelProperty(value = "If the item is bound to a location, it will be specified in this enum.")
  public Object getBindStatus() {
    return bindStatus;
  }

  public void setBindStatus(Object bindStatus) {
    this.bindStatus = bindStatus;
  }

  public DestinyEntitiesItemsDestinyItemComponent location(Object location) {
    this.location = location;
    return this;
  }

   /**
   * An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.
   * @return location
  **/
  @ApiModelProperty(value = "An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.")
  public Object getLocation() {
    return location;
  }

  public void setLocation(Object location) {
    this.location = location;
  }

  public DestinyEntitiesItemsDestinyItemComponent bucketHash(Long bucketHash) {
    this.bucketHash = bucketHash;
    return this;
  }

   /**
   * The hash identifier for the specific inventory bucket in which the item is located.
   * @return bucketHash
  **/
  @ApiModelProperty(value = "The hash identifier for the specific inventory bucket in which the item is located.")
  public Long getBucketHash() {
    return bucketHash;
  }

  public void setBucketHash(Long bucketHash) {
    this.bucketHash = bucketHash;
  }

  public DestinyEntitiesItemsDestinyItemComponent transferStatus(Object transferStatus) {
    this.transferStatus = transferStatus;
    return this;
  }

   /**
   * If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).
   * @return transferStatus
  **/
  @ApiModelProperty(value = "If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).")
  public Object getTransferStatus() {
    return transferStatus;
  }

  public void setTransferStatus(Object transferStatus) {
    this.transferStatus = transferStatus;
  }

  public DestinyEntitiesItemsDestinyItemComponent lockable(Boolean lockable) {
    this.lockable = lockable;
    return this;
  }

   /**
   * If the item can be locked, this will indicate that state.
   * @return lockable
  **/
  @ApiModelProperty(value = "If the item can be locked, this will indicate that state.")
  public Boolean isLockable() {
    return lockable;
  }

  public void setLockable(Boolean lockable) {
    this.lockable = lockable;
  }

  public DestinyEntitiesItemsDestinyItemComponent state(Object state) {
    this.state = state;
    return this;
  }

   /**
   * A flags enumeration indicating the transient/custom states of the item that affect how it is rendered: whether it&#39;s tracked or locked for example, or whether it has a masterwork plug inserted.
   * @return state
  **/
  @ApiModelProperty(value = "A flags enumeration indicating the transient/custom states of the item that affect how it is rendered: whether it's tracked or locked for example, or whether it has a masterwork plug inserted.")
  public Object getState() {
    return state;
  }

  public void setState(Object state) {
    this.state = state;
  }

  public DestinyEntitiesItemsDestinyItemComponent overrideStyleItemHash(Long overrideStyleItemHash) {
    this.overrideStyleItemHash = overrideStyleItemHash;
    return this;
  }

   /**
   * If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.  If you don&#39;t do this, certain items whose styles are being overridden by socketed items - such as the \&quot;Recycle Shader\&quot; item - would show whatever their default icon/style is, and it wouldn&#39;t be pretty or look accurate.
   * @return overrideStyleItemHash
  **/
  @ApiModelProperty(value = "If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.  If you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.")
  public Long getOverrideStyleItemHash() {
    return overrideStyleItemHash;
  }

  public void setOverrideStyleItemHash(Long overrideStyleItemHash) {
    this.overrideStyleItemHash = overrideStyleItemHash;
  }

  public DestinyEntitiesItemsDestinyItemComponent expirationDate(OffsetDateTime expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

   /**
   * If the item can expire, this is the date at which it will/did expire.
   * @return expirationDate
  **/
  @ApiModelProperty(value = "If the item can expire, this is the date at which it will/did expire.")
  public OffsetDateTime getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(OffsetDateTime expirationDate) {
    this.expirationDate = expirationDate;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyEntitiesItemsDestinyItemComponent destinyEntitiesItemsDestinyItemComponent = (DestinyEntitiesItemsDestinyItemComponent) o;
    return Objects.equals(this.itemHash, destinyEntitiesItemsDestinyItemComponent.itemHash) &&
        Objects.equals(this.itemInstanceId, destinyEntitiesItemsDestinyItemComponent.itemInstanceId) &&
        Objects.equals(this.quantity, destinyEntitiesItemsDestinyItemComponent.quantity) &&
        Objects.equals(this.bindStatus, destinyEntitiesItemsDestinyItemComponent.bindStatus) &&
        Objects.equals(this.location, destinyEntitiesItemsDestinyItemComponent.location) &&
        Objects.equals(this.bucketHash, destinyEntitiesItemsDestinyItemComponent.bucketHash) &&
        Objects.equals(this.transferStatus, destinyEntitiesItemsDestinyItemComponent.transferStatus) &&
        Objects.equals(this.lockable, destinyEntitiesItemsDestinyItemComponent.lockable) &&
        Objects.equals(this.state, destinyEntitiesItemsDestinyItemComponent.state) &&
        Objects.equals(this.overrideStyleItemHash, destinyEntitiesItemsDestinyItemComponent.overrideStyleItemHash) &&
        Objects.equals(this.expirationDate, destinyEntitiesItemsDestinyItemComponent.expirationDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(itemHash, itemInstanceId, quantity, bindStatus, location, bucketHash, transferStatus, lockable, state, overrideStyleItemHash, expirationDate);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyEntitiesItemsDestinyItemComponent {\n");
    
    sb.append("    itemHash: ").append(toIndentedString(itemHash)).append("\n");
    sb.append("    itemInstanceId: ").append(toIndentedString(itemInstanceId)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    bindStatus: ").append(toIndentedString(bindStatus)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    bucketHash: ").append(toIndentedString(bucketHash)).append("\n");
    sb.append("    transferStatus: ").append(toIndentedString(transferStatus)).append("\n");
    sb.append("    lockable: ").append(toIndentedString(lockable)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    overrideStyleItemHash: ").append(toIndentedString(overrideStyleItemHash)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

