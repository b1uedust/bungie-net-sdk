/*
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package uk.co.bluedust.model;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;

/**
 * As of Destiny 2, nodes can exist as part of \&quot;Exclusive Groups\&quot;. These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \&quot;opposing\&quot; nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.
 */
@ApiModel(description = "As of Destiny 2, nodes can exist as part of \"Exclusive Groups\". These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \"opposing\" nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-11-04T16:50:06.922Z")
public class DestinyDefinitionsDestinyTalentExclusiveGroup {
  @JsonProperty("groupHash")
  private Integer groupHash = null;

  @JsonProperty("loreHash")
  private Integer loreHash = null;

  @JsonProperty("nodeHashes")
  private List<Integer> nodeHashes = null;

  @JsonProperty("opposingGroupHashes")
  private List<Integer> opposingGroupHashes = null;

  @JsonProperty("opposingNodeHashes")
  private List<Integer> opposingNodeHashes = null;

  public DestinyDefinitionsDestinyTalentExclusiveGroup groupHash(Integer groupHash) {
    this.groupHash = groupHash;
    return this;
  }

   /**
   * The identifier for this exclusive group. Only guaranteed unique within the talent grid, not globally.
   * @return groupHash
  **/
  @ApiModelProperty(value = "The identifier for this exclusive group. Only guaranteed unique within the talent grid, not globally.")
  public Integer getGroupHash() {
    return groupHash;
  }

  public void setGroupHash(Integer groupHash) {
    this.groupHash = groupHash;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup loreHash(Integer loreHash) {
    this.loreHash = loreHash;
    return this;
  }

   /**
   * If this group has an associated piece of lore to show next to it, this will be the identifier for that DestinyLoreDefinition.
   * @return loreHash
  **/
  @ApiModelProperty(value = "If this group has an associated piece of lore to show next to it, this will be the identifier for that DestinyLoreDefinition.")
  public Integer getLoreHash() {
    return loreHash;
  }

  public void setLoreHash(Integer loreHash) {
    this.loreHash = loreHash;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup nodeHashes(List<Integer> nodeHashes) {
    this.nodeHashes = nodeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup addNodeHashesItem(Integer nodeHashesItem) {
    if (this.nodeHashes == null) {
      this.nodeHashes = new ArrayList<>();
    }
    this.nodeHashes.add(nodeHashesItem);
    return this;
  }

   /**
   * A quick reference of the talent nodes that are part of this group, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
   * @return nodeHashes
  **/
  @ApiModelProperty(value = "A quick reference of the talent nodes that are part of this group, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)")
  public List<Integer> getNodeHashes() {
    return nodeHashes;
  }

  public void setNodeHashes(List<Integer> nodeHashes) {
    this.nodeHashes = nodeHashes;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup opposingGroupHashes(List<Integer> opposingGroupHashes) {
    this.opposingGroupHashes = opposingGroupHashes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup addOpposingGroupHashesItem(Integer opposingGroupHashesItem) {
    if (this.opposingGroupHashes == null) {
      this.opposingGroupHashes = new ArrayList<>();
    }
    this.opposingGroupHashes.add(opposingGroupHashesItem);
    return this;
  }

   /**
   * A quick reference of Groups whose nodes will be deactivated if any node in this group is activated.
   * @return opposingGroupHashes
  **/
  @ApiModelProperty(value = "A quick reference of Groups whose nodes will be deactivated if any node in this group is activated.")
  public List<Integer> getOpposingGroupHashes() {
    return opposingGroupHashes;
  }

  public void setOpposingGroupHashes(List<Integer> opposingGroupHashes) {
    this.opposingGroupHashes = opposingGroupHashes;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup opposingNodeHashes(List<Integer> opposingNodeHashes) {
    this.opposingNodeHashes = opposingNodeHashes;
    return this;
  }

  public DestinyDefinitionsDestinyTalentExclusiveGroup addOpposingNodeHashesItem(Integer opposingNodeHashesItem) {
    if (this.opposingNodeHashes == null) {
      this.opposingNodeHashes = new ArrayList<>();
    }
    this.opposingNodeHashes.add(opposingNodeHashesItem);
    return this;
  }

   /**
   * A quick reference of Nodes that will be deactivated if any node in this group is activated, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
   * @return opposingNodeHashes
  **/
  @ApiModelProperty(value = "A quick reference of Nodes that will be deactivated if any node in this group is activated, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)")
  public List<Integer> getOpposingNodeHashes() {
    return opposingNodeHashes;
  }

  public void setOpposingNodeHashes(List<Integer> opposingNodeHashes) {
    this.opposingNodeHashes = opposingNodeHashes;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DestinyDefinitionsDestinyTalentExclusiveGroup destinyDefinitionsDestinyTalentExclusiveGroup = (DestinyDefinitionsDestinyTalentExclusiveGroup) o;
    return Objects.equals(this.groupHash, destinyDefinitionsDestinyTalentExclusiveGroup.groupHash) &&
        Objects.equals(this.loreHash, destinyDefinitionsDestinyTalentExclusiveGroup.loreHash) &&
        Objects.equals(this.nodeHashes, destinyDefinitionsDestinyTalentExclusiveGroup.nodeHashes) &&
        Objects.equals(this.opposingGroupHashes, destinyDefinitionsDestinyTalentExclusiveGroup.opposingGroupHashes) &&
        Objects.equals(this.opposingNodeHashes, destinyDefinitionsDestinyTalentExclusiveGroup.opposingNodeHashes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(groupHash, loreHash, nodeHashes, opposingGroupHashes, opposingNodeHashes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DestinyDefinitionsDestinyTalentExclusiveGroup {\n");
    
    sb.append("    groupHash: ").append(toIndentedString(groupHash)).append("\n");
    sb.append("    loreHash: ").append(toIndentedString(loreHash)).append("\n");
    sb.append("    nodeHashes: ").append(toIndentedString(nodeHashes)).append("\n");
    sb.append("    opposingGroupHashes: ").append(toIndentedString(opposingGroupHashes)).append("\n");
    sb.append("    opposingNodeHashes: ").append(toIndentedString(opposingNodeHashes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

